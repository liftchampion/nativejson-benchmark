<!DOCTYPE html>
<html>
<head>
<title>jsoncons</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1>jsoncons: a C++ library for json construction</h1>

<p>jsoncons is a C++ library for the construction of <a href="http://www.json.org">JavaScript Object Notation (JSON)</a>. It supports parsing a JSON file or string into a <code>json</code> value, building a <code>json</code> value in C++ code, and serializing a <code>json</code> value to a file or string. It also provides an API for generating json read and write events in code, somewhat analogously to SAX processing in the XML world. Consult the wiki for the latest <a href="https://github.com/danielaparker/jsoncons/wiki">documentation and tutorials</a> and <a href="https://github.com/danielaparker/jsoncons/wiki/Roadmap">roadmap</a>. </p>

<p>jsoncons uses some features that are new to C++ 11, particularly <a href="http://thbecker.net/articles/rvalue_references/section_02.html">move semantics</a> and the <a href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a> concept. It has been tested with MS VC++ 2013, MS VC++ 2015, and recent versions of clang and gcc. </p>

<h2>Using the jsoncons library</h2>

<p>The jsoncons library is header-only: it consists solely of header files containing templates and inline functions, and requires no separately-compiled library binaries when linking. It has no dependence on other libraries. </p>

<p>To install the jsoncons library, download the zip file, extract the zipped files, look under <code>src</code> for the directory <code>jsoncons</code>, and copy it to your <code>include</code> directory. If you wish to use extensions, copy the <code>jsoncons_ext</code> directory as well. </p>

<p>The jsoncons classes and functions are in namespace <code>jsoncons</code>. You need to include the header file</p>

<pre><code>#include "jsoncons/json.hpp"
</code></pre>

<p>and, for convenience,</p>

<pre><code>using jsoncons::json;
using jsoncons::json_deserializer;
</code></pre>

<h3>Reading JSON text from a file</h3>

<p>Here is a sample file, <code>books.json</code>:</p>

<div class="highlight highlight-source-c++"><pre>    [
        {
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>Kafka on the Shore<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>Haruki Murakami<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span> : <span class="pl-c1">25.17</span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>Women: A Novel<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>Charles Bukowski<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span> : <span class="pl-c1">12.00</span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>Cutter's Way<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>Ivan Passer<span class="pl-pds">"</span></span>
        }
    ]</pre></div>

<p>It consists of an array of book elements, each element is an object with members title, author, and price.</p>

<p>Read the JSON text into a <code>json</code> value,</p>

<div class="highlight highlight-source-c++"><pre>    std::ifstream <span class="pl-en">is</span>(<span class="pl-s"><span class="pl-pds">"</span>books.json<span class="pl-pds">"</span></span>);
    json books;
    is &gt;&gt; books;</pre></div>

<p>Loop through the book array elements, using either a range-based for loop</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">for</span> (<span class="pl-k">auto</span> book : books.elements())
    {
        std::string author = book[<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;();
        std::string title = book[<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;();
        std::cout &lt;&lt; author &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; title &lt;&lt; std::endl;
    }</pre></div>

<p>or a traditional for loop</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; books.size(); ++i)
    {
        json&amp; book = books[i];
        std::string author = book[<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;();
        std::string title = book[<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;();
        std::cout &lt;&lt; author &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; title &lt;&lt; std::endl;
    }</pre></div>

<p>or begin-end iterators</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">for</span> (<span class="pl-k">auto</span> it = books.elements().begin(); 
         it != books.elements().end();
         ++it)
    {
        std::string author = (*it)[<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;();
        std::string title = (*it)[<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;();
        std::cout &lt;&lt; author &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; title &lt;&lt; std::endl;
    } </pre></div>

<p>The output is</p>

<pre><code>    Haruki Murakami, Kafka on the Shore
    Charles Bukowski, Women: A Novel
    Ivan Passer, Cutter's Way
</code></pre>

<p>Note that the third book, Cutter's Way, is missing a price.</p>

<p>You have a choice of object member accessors:</p>

<div class="highlight highlight-source-c++"><pre>    book[<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>] will <span class="pl-k">throw</span> a `json_exception` <span class="pl-k">if</span> there is no price
    book.get(<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>,default_value) will <span class="pl-k">return</span> `default_value` <span class="pl-k">if</span> there is no price</pre></div>

<p>So if you want to show "n/a" for the missing price, you can use this accessor</p>

<div class="highlight highlight-source-c++"><pre>    std::string price = book.get(<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>n/a<span class="pl-pds">"</span></span>).as&lt;std::string&gt;();</pre></div>

<p>Or you can check if book has a member "price" with the method <code>count</code>, and output accordingly,</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">if</span> (book.count(<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>) &gt; <span class="pl-c1">0</span>)
    {
        <span class="pl-k">double</span> price = book[<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;<span class="pl-k">double</span>&gt;();
        std::cout &lt;&lt; price;
    }
    <span class="pl-k">else</span>
    {
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>n/a<span class="pl-pds">"</span></span>;
    }</pre></div>

<h3>Constructing json values in C++</h3>

<p>To construct an empty json object, use the default constructor:</p>

<div class="highlight highlight-source-c++"><pre>     json image_sizing;</pre></div>

<p>Serializing to standard out</p>

<div class="highlight highlight-source-c++"><pre>    std::cout &lt;&lt; image_sizing &lt;&lt; std::endl;</pre></div>

<p>produces</p>

<div class="highlight highlight-source-json"><pre>    {}</pre></div>

<p>Setting some name-value pairs,</p>

<div class="highlight highlight-source-c++"><pre>    image_sizing[<span class="pl-s"><span class="pl-pds">"</span>resize_to_fit<span class="pl-pds">"</span></span>] = <span class="pl-c1">true</span>;  <span class="pl-c">// a boolean </span>
    image_sizing[<span class="pl-s"><span class="pl-pds">"</span>resize_unit<span class="pl-pds">"</span></span>]   = <span class="pl-s"><span class="pl-pds">"</span>pixels<span class="pl-pds">"</span></span>;  <span class="pl-c">// a string</span>
    image_sizing[<span class="pl-s"><span class="pl-pds">"</span>resize_what<span class="pl-pds">"</span></span>]   = <span class="pl-s"><span class="pl-pds">"</span>long_edge<span class="pl-pds">"</span></span>;  <span class="pl-c">// a string</span>
    image_sizing[<span class="pl-s"><span class="pl-pds">"</span>dimension1<span class="pl-pds">"</span></span>]    = <span class="pl-c1">9.84</span>;  <span class="pl-c">// a double</span>
    image_sizing[<span class="pl-s"><span class="pl-pds">"</span>dimension2<span class="pl-pds">"</span></span>]    = json::null_type();  <span class="pl-c">// a null</span></pre></div>

<p>Serializing again, this time with pretty print,</p>

<div class="highlight highlight-source-c++"><pre>    std::cout &lt;&lt; pretty_print(image_sizing) &lt;&lt; std::endl;</pre></div>

<p>produces</p>

<div class="highlight highlight-source-json"><pre>    {
        <span class="pl-s"><span class="pl-pds">"</span>dimension1<span class="pl-pds">"</span></span>:<span class="pl-c1">9.84</span>,
        <span class="pl-s"><span class="pl-pds">"</span>dimension2<span class="pl-pds">"</span></span>:<span class="pl-c1">null</span>,
        <span class="pl-s"><span class="pl-pds">"</span>resize_to_fit<span class="pl-pds">"</span></span>:<span class="pl-c1">true</span>,
        <span class="pl-s"><span class="pl-pds">"</span>resize_unit<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>pixels<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>resize_what<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>long_edge<span class="pl-pds">"</span></span>
    }</pre></div>

<p>To construct a json array, use an initializer list:</p>

<div class="highlight highlight-source-c++"><pre>    json image_formats = {<span class="pl-s"><span class="pl-pds">"</span>JPEG<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>PSD<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>TIFF<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>DNG<span class="pl-pds">"</span></span>};</pre></div>

<p>or initialize with the array type and use the <code>add</code> function:</p>

<div class="highlight highlight-source-c++"><pre>    json color_spaces{<span class="pl-c1">json::array</span>()};
    color_spaces.add(<span class="pl-s"><span class="pl-pds">"</span>sRGB<span class="pl-pds">"</span></span>);
    color_spaces.add(<span class="pl-s"><span class="pl-pds">"</span>AdobeRGB<span class="pl-pds">"</span></span>);
    color_spaces.add(<span class="pl-s"><span class="pl-pds">"</span>ProPhoto RGB<span class="pl-pds">"</span></span>);</pre></div>

<p>Combining these three </p>

<div class="highlight highlight-source-c++"><pre>    json file_export;
    file_export[<span class="pl-s"><span class="pl-pds">"</span>image_sizing<span class="pl-pds">"</span></span>] = std::move(image_sizing);
    file_export[<span class="pl-s"><span class="pl-pds">"</span>image_formats<span class="pl-pds">"</span></span>] = std::move(image_formats);
    file_export[<span class="pl-s"><span class="pl-pds">"</span>color_spaces<span class="pl-pds">"</span></span>] = std::move(color_spaces);</pre></div>

<p>and serializing</p>

<div class="highlight highlight-source-c++"><pre>    std::cout &lt;&lt; pretty_print(file_export) &lt;&lt; std::endl;</pre></div>

<p>produces</p>

<div class="highlight highlight-source-json"><pre>    {
        <span class="pl-s"><span class="pl-pds">"</span>color_spaces<span class="pl-pds">"</span></span>:
        [<span class="pl-s"><span class="pl-pds">"</span>sRGB<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>AdobeRGB<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>ProPhoto RGB<span class="pl-pds">"</span></span>],
        <span class="pl-s"><span class="pl-pds">"</span>image_formats<span class="pl-pds">"</span></span>:
        [<span class="pl-s"><span class="pl-pds">"</span>JPEG<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>PSD<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>TIFF<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>DNG<span class="pl-pds">"</span></span>],
        <span class="pl-s"><span class="pl-pds">"</span>image_sizing<span class="pl-pds">"</span></span>:
        {
            <span class="pl-s"><span class="pl-pds">"</span>dimension1<span class="pl-pds">"</span></span>:<span class="pl-c1">9.84</span>,
            <span class="pl-s"><span class="pl-pds">"</span>dimension2<span class="pl-pds">"</span></span>:<span class="pl-c1">null</span>,
            <span class="pl-s"><span class="pl-pds">"</span>resize_to_fit<span class="pl-pds">"</span></span>:<span class="pl-c1">true</span>,
            <span class="pl-s"><span class="pl-pds">"</span>resize_unit<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>pixels<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>resize_what<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>long_edge<span class="pl-pds">"</span></span>
        }
    }</pre></div>

<h3>Converting CSV files to json</h3>

<p>Here is a sample CSV file (tasks.csv):</p>

<pre><code>    project_id, task_name, task_start, task_finish
    4001,task1,01/01/2003,01/31/2003
    4001,task2,02/01/2003,02/28/2003
    4001,task3,03/01/2003,03/31/2003
    4002,task1,04/01/2003,04/30/2003
    4002,task2,05/01/2003,
</code></pre>

<p>You can read the <code>CSV</code> file into a <code>json</code> value with the <code>csv_reader</code>.</p>

<div class="highlight highlight-source-c++"><pre>    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jsoncons_ext/csv/csv_reader.hpp<span class="pl-pds">"</span></span>

    <span class="pl-k">using</span> jsoncons::csv::csv_parameters;
    <span class="pl-k">using</span> jsoncons::csv::csv_reader;

    std::fstream <span class="pl-en">is</span>(<span class="pl-s"><span class="pl-pds">"</span>tasks.csv<span class="pl-pds">"</span></span>);

    json_deserializer handler;

    csv_parameters params;
    params.assume_header(<span class="pl-c1">true</span>);
    params.trim(<span class="pl-c1">true</span>);
    params.ignore_empty_values(<span class="pl-c1">true</span>);
    params.column_types({<span class="pl-s"><span class="pl-pds">"</span>integer<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>});

    csv_reader <span class="pl-en">reader</span>(is,handler,params);
    reader.read();
    json val = handler.get_result();

    std::cout &lt;&lt; pretty_print(val) &lt;&lt; std::endl;</pre></div>

<p>The output is:</p>

<div class="highlight highlight-source-json"><pre>    [
        {
            <span class="pl-s"><span class="pl-pds">"</span>project_id<span class="pl-pds">"</span></span>:<span class="pl-c1">4001</span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_finish<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>01/31/2003<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_name<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>task1<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_start<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>01/01/2003<span class="pl-pds">"</span></span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>project_id<span class="pl-pds">"</span></span>:<span class="pl-c1">4001</span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_finish<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>02/28/2003<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_name<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>task2<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_start<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>02/01/2003<span class="pl-pds">"</span></span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>project_id<span class="pl-pds">"</span></span>:<span class="pl-c1">4001</span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_finish<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>03/31/2003<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_name<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>task3<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_start<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>03/01/2003<span class="pl-pds">"</span></span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>project_id<span class="pl-pds">"</span></span>:<span class="pl-c1">4002</span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_finish<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>04/30/2003<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_name<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>task1<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_start<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>04/01/2003<span class="pl-pds">"</span></span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>project_id<span class="pl-pds">"</span></span>:<span class="pl-c1">4002</span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_name<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>task2<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>task_start<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>05/01/2003<span class="pl-pds">"</span></span>
        }
    ]</pre></div>

<p>There are a few things to note about the effect of the parameter settings.</p>

<ul>
<li>
<code>assume_header</code> <code>true</code> tells the csv parser to parse the first line of the file for column names, which become object member names.</li>
<li>
<code>trim</code> <code>true</code> tells the parser to trim leading and trailing whitespace, in particular, to remove the leading whitespace in the column names.</li>
<li>
<code>ignore_empty_values</code> <code>true</code> causes the empty last value in the <code>task_finish</code> column to be omitted.</li>
<li>The <code>column_types</code> setting specifies that column one ("project_id") contains integers and the remaining columns strings.</li>
</ul>

<h3>Iterators</h3>

<p><code>jsoncons::json</code> supports iterators for accessing the members of json objects and the elements of json arrays.</p>

<p>An example of iterating over the name-value pairs of a json object:</p>

<div class="highlight highlight-source-c++"><pre>    json person;
    person[<span class="pl-s"><span class="pl-pds">"</span>first_name<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>Jane<span class="pl-pds">"</span></span>;
    person[<span class="pl-s"><span class="pl-pds">"</span>last_name<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>Roe<span class="pl-pds">"</span></span>;
    person[<span class="pl-s"><span class="pl-pds">"</span>events_attended<span class="pl-pds">"</span></span>] = <span class="pl-c1">10</span>;
    person[<span class="pl-s"><span class="pl-pds">"</span>accept_waiver_of_liability<span class="pl-pds">"</span></span>] = <span class="pl-c1">true</span>;

    <span class="pl-k">for</span> (<span class="pl-k">auto</span> it = person.members().begin(); it != person.members().end(); ++it)
    {
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>name=<span class="pl-pds">"</span></span> &lt;&lt; it-&gt;<span class="pl-c1">name</span>() 
                  &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, value=<span class="pl-pds">"</span></span> &lt;&lt; it-&gt;<span class="pl-c1">value</span>().<span class="pl-smi">as</span>&lt;std::string&gt;() &lt;&lt; std::endl;
    }</pre></div>

<p>An example of iterating over the elements of a json array:</p>

<div class="highlight highlight-source-c++"><pre>    json cities = json::array();
    cities.add(<span class="pl-s"><span class="pl-pds">"</span>Montreal<span class="pl-pds">"</span></span>);
    cities.add(<span class="pl-s"><span class="pl-pds">"</span>Toronto<span class="pl-pds">"</span></span>);
    cities.add(<span class="pl-s"><span class="pl-pds">"</span>Ottawa<span class="pl-pds">"</span></span>);
    cities.add(<span class="pl-s"><span class="pl-pds">"</span>Vancouver<span class="pl-pds">"</span></span>);

    <span class="pl-k">for</span> (<span class="pl-k">auto</span> it = cities.elements().begin(); it != cities.elements().end(); ++it)
    {
        std::cout &lt;&lt; it-&gt;as&lt;std::string&gt;() &lt;&lt; std::endl;
    }</pre></div>

<h3>jsonpath</h3>

<p><a href="http://goessner.net/articles/JsonPath/">Stefan Goessner's JsonPath</a> is an XPATH inspired query language for selecting parts of a JSON structure.</p>

<p>Here is a sample JSON file (store.json):</p>

<div class="highlight highlight-source-json"><pre>    { <span class="pl-s"><span class="pl-pds">"</span>store<span class="pl-pds">"</span></span>: {
        <span class="pl-s"><span class="pl-pds">"</span>book<span class="pl-pds">"</span></span>: [ 
          { <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>reference<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Nigel Rees<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Sayings of the Century<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>: <span class="pl-c1">8.95</span>
          },
          { <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fiction<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Evelyn Waugh<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Sword of Honour<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>: <span class="pl-c1">12.99</span>
          },
          { <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fiction<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Herman Melville<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Moby Dick<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>0-553-21311-3<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>: <span class="pl-c1">8.99</span>
          },
          { <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fiction<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>J. R. R. Tolkien<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>The Lord of the Rings<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>0-395-19395-8<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>: <span class="pl-c1">22.99</span>
          }
        ]
      }
    }</pre></div>

<p>The following code returns all authors whose books are cheaper than $10. </p>

<div class="highlight highlight-source-c++"><pre>    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jsoncons_ext/jsonpath/json_query.hpp<span class="pl-pds">"</span></span>

    <span class="pl-k">using</span> jsoncons::jsonpath::json_query;

    json root = json::parse_file(<span class="pl-s"><span class="pl-pds">"</span>store.json<span class="pl-pds">"</span></span>);

    <span class="pl-c">// (1) The authors of books that are cheaper than $10</span>
    json result = json_query(root,<span class="pl-s"><span class="pl-pds">"</span>$.store.book[?(@.price &lt; 10)].author<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (2) The number of books</span>
    json result = json_query(root,<span class="pl-s"><span class="pl-pds">"</span>$..book.length<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (3) The third book</span>
    json result = json_query(root,<span class="pl-s"><span class="pl-pds">"</span>$..book[2]<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; pretty_print(result) &lt;&lt; std::endl;

    <span class="pl-c">// (4) All books whose author's name starts with Evelyn</span>
    json result = json_query(root,<span class="pl-s"><span class="pl-pds">"</span>$.store.book[?(@.author =~ /Evelyn.*?/)]<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; pretty_print(result) &lt;&lt; std::endl;

    <span class="pl-c">// (5) The titles of all books that have isbn number</span>
    json result = json_query(root,<span class="pl-s"><span class="pl-pds">"</span>$..book[?(@.isbn)]/title<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; result &lt;&lt; std::endl;</pre></div>

<p>Result:</p>

<div class="highlight highlight-source-json"><pre>    (<span class="pl-c1">1</span>) [<span class="pl-s"><span class="pl-pds">"</span>Nigel Rees<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Herman Melville<span class="pl-pds">"</span></span>]
    (<span class="pl-c1">2</span>) [<span class="pl-c1">4</span>]
    (<span class="pl-c1">3</span>) [
            {
                <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fiction<span class="pl-pds">"</span></span>,
                <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Herman Melville<span class="pl-pds">"</span></span>,
                <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Moby Dick<span class="pl-pds">"</span></span>,
                <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>0-553-21311-3<span class="pl-pds">"</span></span>,
                <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>: <span class="pl-c1">8.99</span>
            }
        ]
    (<span class="pl-c1">4</span>) [
            {
                <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fiction<span class="pl-pds">"</span></span>,
                <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Evelyn Waugh<span class="pl-pds">"</span></span>,
                <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Sword of Honour<span class="pl-pds">"</span></span>,
                <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>: <span class="pl-c1">12.99</span>
            }
        ]
    (<span class="pl-c1">5</span>) [<span class="pl-s"><span class="pl-pds">"</span>Moby Dick<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>The Lord of the Rings<span class="pl-pds">"</span></span>] </pre></div>

<h3>About jsoncons::json</h3>

<p>The json class is an instantiation of the <code>basic_json</code> class template that uses <code>std::string</code> as the string type<br>
and <code>std::allocator&lt;void&gt;</code> as the allocator type,</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">typedef</span> basic_json&lt;<span class="pl-k">char</span>,std::allocator&lt;<span class="pl-k">char</span>&gt;&gt; json</pre></div>

<p>The <code>jsoncons</code> library will always rebind the given allocator from the template parameter to internal data structures.</p>

<p>The library includes an instantiation for wide characters as well,</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">typedef</span> basic_json&lt;<span class="pl-c1">wchar_t</span>,std::allocator&lt;<span class="pl-c1">wchar_t</span>&gt;&gt; wjson</pre></div>

<p>Note that the allocator type allows you to supply a custom allocator. For example, you can use the boost <a href="http://www.boost.org/doc/libs/1_60_0/libs/pool/doc/html/boost/fast_pool_allocator.html">fast_pool_allocator</a>:</p>

<div class="highlight highlight-source-c++"><pre>    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/pool/pool_alloc.hpp<span class="pl-pds">&gt;</span></span>
    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jsoncons/json.hpp<span class="pl-pds">"</span></span>

    <span class="pl-k">typedef</span> jsoncons::basic_json&lt;<span class="pl-k">char</span>, boost::fast_pool_allocator&lt;<span class="pl-k">char</span>&gt;&gt; myjson;

    myjson o;

    o.set(<span class="pl-s"><span class="pl-pds">"</span>FirstName<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>);
    o.set(<span class="pl-s"><span class="pl-pds">"</span>LastName<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Smith<span class="pl-pds">"</span></span>);</pre></div>

<p>This results in a json value being constucted with all memory being allocated from the boost memory pool. (In this particular case there is no improvement in performance over <code>std::allocator</code>.)</p>

<p>Note that the underlying memory pool used by the <code>boost::fast_pool_allocator</code> is never freed. </p>

<h2>Wide character support</h2>

<p>jsoncons supports wide character strings and streams with <code>wjson</code> and <code>wjson_reader</code>. It supports <code>UTF16</code> encoding if <code>wchar_t</code> has size 2 (Windows) and <code>UTF32</code> encoding if <code>wchar_t</code> has size 4. You can construct a <code>wjson</code> value in exactly the same way as a <code>json</code> value, for instance:</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">using</span> jsoncons::wjson;

    wjson root;
    root[L<span class="pl-s"><span class="pl-pds">"</span>field1<span class="pl-pds">"</span></span>] = L<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>;
    root[L<span class="pl-s"><span class="pl-pds">"</span>field2<span class="pl-pds">"</span></span>] = <span class="pl-c1">3.9</span>;
    root[L<span class="pl-s"><span class="pl-pds">"</span>field3<span class="pl-pds">"</span></span>] = <span class="pl-c1">true</span>;

    std::wcout &lt;&lt; root &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;</pre></div>

<p>which prints</p>

<div class="highlight highlight-source-c++"><pre>    {<span class="pl-s"><span class="pl-pds">"</span>field1<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>field2<span class="pl-pds">"</span></span>:<span class="pl-c1">3.9</span>,<span class="pl-s"><span class="pl-pds">"</span>field3<span class="pl-pds">"</span></span>:<span class="pl-c1">true</span>}</pre></div>

<h3>Type extensibility</h3>

<p>In the json class, constructors, accessors and modifiers are templated, for example,</p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">explicit</span> <span class="pl-en">json</span>(T val)

    template&lt;typename T&gt;
    bool is() <span class="pl-k">const</span>

    template&lt;typename T&gt;
    T as() <span class="pl-k">const</span>

    template &lt;typename T&gt;
    basic_json&amp; operator=(T val)

    template &lt;typename T&gt;
    void add(T val)</pre></div>

<p>The implementations of these functions and operators make use of the class template <code>json_type_traits</code></p>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">JsonT</span>, <span class="pl-k">typename</span> T&gt;
    <span class="pl-k">class</span> <span class="pl-en">json_type_traits</span>
    {
    <span class="pl-k">public:</span>
        <span class="pl-k">static</span> <span class="pl-k">bool</span> <span class="pl-en">is</span>(<span class="pl-k">const</span> JsonT&amp; rhs) <span class="pl-k">noexcept</span>;
        <span class="pl-k">static</span> T <span class="pl-en">as</span>(<span class="pl-k">const</span> JsonT&amp; rhs);
        <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">assign</span>(JsonT&amp; lhs, T rhs);
    };</pre></div>

<p>This class template is extensible, you as a user can extend <code>json_type_traits</code> in the <code>jsoncons</code> namespace with your own types. You can, for example, extend <code>json_type_traits</code> to access and modify <code>json</code> structures with <code>boost::gregorian::date values</code>, and in your code, write</p>

<div class="highlight highlight-source-c++"><pre>    json deal;
    deal[<span class="pl-s"><span class="pl-pds">"</span>maturity<span class="pl-pds">"</span></span>] = boost::gregorian::date(<span class="pl-c1">2015</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>);

    json observation_dates = json::array();
    observation_dates.add(boost::gregorian::date(<span class="pl-c1">2013</span>,<span class="pl-c1">10</span>,<span class="pl-c1">21</span>));
    observation_dates.add(boost::gregorian::date(<span class="pl-c1">2013</span>,<span class="pl-c1">10</span>,<span class="pl-c1">28</span>));
    deal[<span class="pl-s"><span class="pl-pds">"</span>observation_dates<span class="pl-pds">"</span></span>] = std::move(observation_dates);

    boost::gregorian::date maturity = deal[<span class="pl-s"><span class="pl-pds">"</span>maturity<span class="pl-pds">"</span></span>].as&lt;boost::gregorian::date&gt;();

    std::cout &lt;&lt; deal &lt;&lt; std::endl;     </pre></div>

<p>producing</p>

<div class="highlight highlight-source-c++"><pre>    {
        <span class="pl-s"><span class="pl-pds">"</span>maturity<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>2015-01-01<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>observation_dates<span class="pl-pds">"</span></span>:
        [<span class="pl-s"><span class="pl-pds">"</span>2013-10-21<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>2013-10-28<span class="pl-pds">"</span></span>]
    }</pre></div>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
